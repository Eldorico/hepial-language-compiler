import java_cup.runtime.*;
import java.util.Stack;
import java.util.AbstractMap.SimpleEntry;
import abstractTree.AbstractTree;
import abstractTree.expression.*;
import abstractTree.instruction.*;

init with {:
  abstractTreeStack = new Stack<AbstractTree>();
:};

parser code {:
  Stack<AbstractTree> abstractTreeStack;
:};

terminal SimpleEntry<String, Integer>  ident;
terminal SimpleEntry<String, Integer>  constanteEnt;
terminal SimpleEntry<String, Integer>  constanteChaine;

terminal SimpleEntry<String, Integer> keyword_debutprg;
terminal SimpleEntry<String, Integer> keyword_finprg;
terminal SimpleEntry<String, Integer> keyword_programme;
terminal SimpleEntry<String, Integer> keyword_constante;
terminal SimpleEntry<String, Integer> keyword_debutfonc;
terminal SimpleEntry<String, Integer> keyword_finfonc;
terminal SimpleEntry<String, Integer> keyword_entier;
terminal SimpleEntry<String, Integer> keyword_booleen;
terminal SimpleEntry<String, Integer> keyword_lire;
terminal SimpleEntry<String, Integer> keyword_ecrire;
terminal SimpleEntry<String, Integer> keyword_retourne;
terminal SimpleEntry<String, Integer> keyword_si;
terminal SimpleEntry<String, Integer> keyword_alors;
terminal SimpleEntry<String, Integer> keyword_sinon;
terminal SimpleEntry<String, Integer> keyword_finsi;
terminal SimpleEntry<String, Integer> keyword_tantque;
terminal SimpleEntry<String, Integer> keyword_faire;
terminal SimpleEntry<String, Integer> keyword_fintantque;
terminal SimpleEntry<String, Integer> keyword_pour;
terminal SimpleEntry<String, Integer> keyword_allantde;
terminal SimpleEntry<String, Integer> keyword_a;
terminal SimpleEntry<String, Integer> keyword_finpour;
terminal SimpleEntry<String, Integer> keyword_vrai;
terminal SimpleEntry<String, Integer> keyword_faux;
terminal SimpleEntry<String, Integer> keyword_et;
terminal SimpleEntry<String, Integer> keyword_ou;
terminal SimpleEntry<String, Integer> keyword_non;

terminal SimpleEntry<String, Integer> char_plus;
terminal SimpleEntry<String, Integer> char_moins;
terminal SimpleEntry<String, Integer> char_fois;
terminal SimpleEntry<String, Integer> char_div;
terminal SimpleEntry<String, Integer> char_egal;
terminal SimpleEntry<String, Integer> char_egal_egal;
terminal SimpleEntry<String, Integer> char_different;
terminal SimpleEntry<String, Integer> char_ppetit;
terminal SimpleEntry<String, Integer> char_pgrand;
//terminal SimpleEntry<String, Integer> char_ppetit_pgrand;
terminal SimpleEntry<String, Integer> char_ppetit_egal;
terminal SimpleEntry<String, Integer> char_pgrand_egal;
terminal SimpleEntry<String, Integer> char_non;
terminal SimpleEntry<String, Integer> char_par_ouvr;
terminal SimpleEntry<String, Integer> char_par_ferm;
terminal SimpleEntry<String, Integer> char_crochet_ouvr;
terminal SimpleEntry<String, Integer> char_crochet_ferm;
terminal SimpleEntry<String, Integer> char_virgule;
terminal SimpleEntry<String, Integer> char_point_virgule;
terminal SimpleEntry<String, Integer> char_point_point;

non terminal AXIOME;
non terminal PROGRAMME;
non terminal ENTETE;
non terminal DECLA;
non terminal DECLAVAR;
non terminal LIDENT;
non terminal DECLACONST;
non terminal DECLAFONCT;
non terminal TYPE;
non terminal TYPEBASE;
non terminal TABLEAU;
non terminal DIM;
non terminal PARAM;
non terminal Instruction INSTR;
non terminal BlocInstruction CORPS; // TODO: explain somewhere that a CORPS is a list of instcutions...
non terminal LIRE;
non terminal ECRIRE;
non terminal AFFECTATION;
non terminal RETOUR;
non terminal CONDITION;
non terminal TANTQUE;
non terminal POUR;
non terminal Expression EXPR;
non terminal ACCES;
non terminal INDEX;
non terminal LISTE_INDEX;
non terminal OPERANDE;
non terminal SimpleEntry<String, Integer> OPEUN; // <String value, lineNumber>
non terminal APPELFCT;
non terminal PAREFF;

non terminal ENDASDF; // for debugging

precedence left keyword_ou, char_plus, char_moins;
precedence left keyword_et, char_fois, char_div;
precedence left char_ppetit, char_pgrand, char_ppetit_egal, char_pgrand_egal, char_egal_egal, char_different;


/***************************
 *        GRAMMAR          *
 ***************************/

ENDASDF ::= CORPS {:
        System.out.printf("Terminé stackSize = %d.  to string : \n%s", parser.abstractTreeStack.size(), parser.abstractTreeStack.peek().toString());
      :}
      ;

/*

 PROGRAMME  ::= ENTETE DECLA* 'debutprg' CORPS 'finprg' {:
                  //System.out.printf("detecté programme\n");
              :}
              ;

 ENTETE     ::= 'programme' ident:i {:
                  //System.out.printf("nom du programme: %s\n", i.getKey());
              :}
              ;
*/
/*
 DECLA      ::= DECLAVAR
              | DECLACONST
              | DECLAFONCT
              ;
*/
/*
DECLAVAR   ::= TYPE:t LIDENT ';' {:
                 //System.out.printf("var %s (%s)\n", i, t.getKey());
             :}
             ;
 LIDENT     ::= ident
              | LIDENT ',' ident
              ;
 DECLACONST ::= 'constante' TYPE ident '=' EXPR ';';
 DECLAFONCT ::= TYPE ident '(' PARAM ')' DECLA* 'debutfonc' CORPS 'finfonc'
              | TYPE ident '(' ')' DECLA* 'debutfonc' CORPS 'finfonc'
              ;
 TYPE       ::= TYPEBASE:t {:
                  //RESULT = t;
              :}
              | TABLEAU:t {:
                  //RESULT = t;
              :}
              ;
 TYPEBASE   ::= 'entier' {:
                  //RESULT = new String("entier");
              :}
              |  'booleen' {:
                  //RESULT = new String("boolen");
              :}
              ;
 TABLEAU    ::= TYPEBASE:t '[' DIM:d ']' {:
                  //RESULT = new String(t+"["+d+"]");
              :}
              ;
 DIM        ::= EXPR:e1 '..' EXPR:e2 {:
                  //RESULT = new String(e1+".."+e2);
              :}
              |  DIM:d ',' EXPR:e1 '..' EXPR:e2; {:
                  //RESULT = new String(d+","+e1+".."+e2);
              :}
 PARAM      ::= TYPE:t ident:i {:
                  //RESULT = new String(t+" "i);
              :}
              |  PARAM:p ',' TYPE:t ident:i {:
                  //RESULT = new String(p+", "+t+" "+i);
              :}
              ;
*/

CORPS      ::= INSTR {:
                // if instruction on the top of the stack is not a BlocInstruction, convert the instruction to a BlocInstruction and put it on the top of the list. //TODO: could remove this check?
                if(!parser.abstractTreeStack.peek().getClass().equals(BlocInstruction.class)){
                    Instruction instruct = (Instruction) parser.abstractTreeStack.pop();
                    parser.abstractTreeStack.add(new BlocInstruction(instruct));
                }
              :}
              | INSTR CORPS {:
                  // add the instruction to the CORPS and put it on the top of the abstractTreeStack
                  BlocInstruction block = (BlocInstruction) parser.abstractTreeStack.pop();
                  Instruction instruct = (Instruction) parser.abstractTreeStack.pop();
                  block.addInstruction(instruct);
                  parser.abstractTreeStack.add(block);
              :}
              ;

INSTR      ::= AFFECTATION
              | ECRIRE
              | LIRE
              | CONDITION
              | RETOUR
              | TANTQUE
              | POUR
              ;
/*
 LIRE       ::= keyword_lire ident:i char_point_virgule {:
                  System.out.printf("Lire: %s<-stdin\n", i.getKey());
              :}
              ;
 ECRIRE     ::= keyword_ecrire EXPR:e char_point_virgule {:
                  System.out.printf("Ecrire: %s\n", e);
              :}
              | keyword_ecrire constanteChaine:c char_point_virgule {:
                  System.out.printf("Ecrire: %s\n", c.getKey());
              :}
              ;
*/
AFFECTATION ::= ACCES:a char_egal EXPR char_point_virgule  {:
                  // pop the expression
                  Expression src = (Expression) parser.abstractTreeStack.pop();

                  // pop the ACCES
                  Expression dst = (Expression) parser.abstractTreeStack.pop();

                  // add the affectation to the stack as a new Instruction
                  parser.abstractTreeStack.add(new AffectationInstruction(dst, src));
              :}
              ;
 /*
 RETOUR     ::= 'retourne' EXPR ';';
 */

CONDITION  ::= keyword_si EXPR keyword_alors CORPS keyword_sinon CORPS keyword_finsi {:
                  // pop the two blocs instructions
                  BlocInstruction elseBlocInstructions = (BlocInstruction) parser.abstractTreeStack.pop();
                  BlocInstruction thenBlocInstructions = (BlocInstruction) parser.abstractTreeStack.pop();
                  Expression conditionExpression = (Expression) parser.abstractTreeStack.pop();

                  // create a conditionInstruction and put it on the top of the stack
                  parser.abstractTreeStack.add(new IfInstruction(conditionExpression, thenBlocInstructions, elseBlocInstructions));
              :}
              ;

TANTQUE    ::= keyword_tantque EXPR keyword_faire CORPS keyword_fintantque {:
                  // pop the needed blocs
                  BlocInstruction instructions = (BlocInstruction) parser.abstractTreeStack.pop();
                  Expression condition = (Expression) parser.abstractTreeStack.pop();

                  // create a while instruction
                  parser.abstractTreeStack.add(new WhileLoopInstrcution(condition, instructions));
              :}
              ;

POUR       ::= keyword_pour ident:id keyword_allantde EXPR keyword_a EXPR keyword_faire CORPS keyword_finpour {:
                  // pop the needed blocs
                  Identifier i = new Identifier(id.getKey());
                  BlocInstruction instructions = (BlocInstruction) parser.abstractTreeStack.pop();
                  Expression upperBound = (Expression) parser.abstractTreeStack.pop();
                  Expression lowerBound = (Expression) parser.abstractTreeStack.pop();

                  // create a for loop Instruction
                  parser.abstractTreeStack.add(new ForLoopInstruction(i, lowerBound, upperBound, instructions));
              :}
              ;

EXPR       ::=  EXPR char_plus EXPR {:
                  parser.abstractTreeStack.add(new AdditionExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_moins EXPR {:
                  parser.abstractTreeStack.add(new SubstractionExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_fois EXPR {:
                  parser.abstractTreeStack.add(new MultiplyExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_div EXPR {:
                  parser.abstractTreeStack.add(new DivideExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_egal_egal EXPR {:
                  parser.abstractTreeStack.add(new EqualEqualExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_different EXPR {:
                  parser.abstractTreeStack.add(new DifferentThanExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_ppetit EXPR {:
                  parser.abstractTreeStack.add(new LesserThanExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_pgrand EXPR {:
                  parser.abstractTreeStack.add(new GreaterThanExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_ppetit_egal EXPR {:
                  parser.abstractTreeStack.add(new LesserEqualExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR char_pgrand_egal EXPR {:
                  parser.abstractTreeStack.add(new GreaterEqualExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR keyword_et EXPR {:
                  parser.abstractTreeStack.add(new AndExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | EXPR keyword_ou EXPR {:
                  parser.abstractTreeStack.add(new OrExpression((Expression)parser.abstractTreeStack.pop(), (Expression)parser.abstractTreeStack.pop()));
              :}
              | OPEUN:o EXPR:e {:
                  Expression expression = (Expression)parser.abstractTreeStack.pop();
                  String strOperatorValue = o.getKey();
                  switch(strOperatorValue){
                    case "!":
                    case "non":
                      parser.abstractTreeStack.add(new NotExpression(expression));
                      break;
                  }
              :}
              | char_par_ouvr EXPR char_par_ferm
              | OPERANDE
              ;

ACCES      ::= ident:i{:
                  // add ident to the stack
                  parser.abstractTreeStack.add(new Identifier(i.getKey()));
              :}
              | ident:i LISTE_INDEX {:
                  // pop the ExpressionListpression from the stack and create a new TabValueIndentifier
                  ExpressionList indexes = (ExpressionList) parser.abstractTreeStack.pop();
                  parser.abstractTreeStack.add(new TabValueIndentifier(i.getKey(), indexes));
              :}
              ;


LISTE_INDEX  ::= INDEX:i {:
                  // pop the first index and create an ExpressionList
                  Expression index = (Expression) parser.abstractTreeStack.pop();
                  // place the ExpressionList on the top of the stack
                  parser.abstractTreeStack.add(new ExpressionList(index));
              :}
              | INDEX:i LISTE_INDEX:l {:
                  // add the index to the ExpressionList and put it on the top of the stack
                  ExpressionList indexes = (ExpressionList) parser.abstractTreeStack.pop();
                  Expression index = (Expression) parser.abstractTreeStack.pop();
                  indexes.addExpression(index);
                  parser.abstractTreeStack.add(indexes);
              :}
              ;

INDEX      ::= char_crochet_ouvr EXPR char_crochet_ferm {:
                  // do nothing. The expression of the be placed on the stack in the EXPR reduction
              :}
              ;

OPERANDE   ::= ACCES
              | APPELFCT
              | constanteEnt:c {:
                  parser.abstractTreeStack.add(new IntNumber(Integer.valueOf(c.getKey())));
              :}
              | keyword_vrai {:
                  parser.abstractTreeStack.add(new BooleanKeyword(true));
              :}
              | keyword_faux {:
                  parser.abstractTreeStack.add(new BooleanKeyword(false));
              :}
              ;

OPEUN      ::= char_non:c {:
                  RESULT = c;
              :}
              | keyword_non:c {:
                  RESULT = c;
              :}
              ;
/*
APPELFCT   ::= ident:i char_par_ouvr char_par_ferm {:
                  RESULT = new String(String.format("%s()", i.getKey()));
              :}
              | ident:i char_par_ouvr PAREFF:p char_par_ferm {:
                  RESULT = new String(String.format("%s(%s)", i.getKey(), p));
              :}
              ;
PAREFF     ::= EXPR:e {:
                  RESULT = new String(e);
              :}
              | PAREFF:p char_virgule EXPR:e {:
                 RESULT = new String(p+", "+e);
              :}
              ;
*/
